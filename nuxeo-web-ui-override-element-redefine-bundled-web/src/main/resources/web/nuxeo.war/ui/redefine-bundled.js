"use strict";const cer=customElements,NativeHTMLElement=HTMLElement,{hasAttribute:nativeHasAttribute,setAttribute:nativeSetAttribute,removeAttribute:nativeRemoveAttribute,getAttribute:nativeGetAttribute}=NativeHTMLElement.prototype,{apply:ReflectApply,setPrototypeOf:ReflectSetPrototypeOf,construct:ReflectConstruct}=Reflect,ObjectDefineProperties=Object["defineProperties"],{get:nativeGet,define:nativeDefine,whenDefined:nativeWhenDefined}=CustomElementRegistry.prototype,nativeNodeIsConnectedGetter=Object.getOwnPropertyDescriptor(Node.prototype,"isConnected").get;function valueToString(e){try{return String(e)}catch{}return""}function createDefinitionRecord(e){var{connectedCallback:t,disconnectedCallback:i,adoptedCallback:n,attributeChangedCallback:r,formAssociatedCallback:a,formDisabledCallback:o,formResetCallback:s,formStateRestoreCallback:l}=e.prototype;return{LatestCtor:e,connectedCallback:t,disconnectedCallback:i,adoptedCallback:n,formAssociatedCallback:a,formDisabledCallback:o,formResetCallback:s,formStateRestoreCallback:l,attributeChangedCallback:r,observedAttributes:new Set(e.observedAttributes||[])}}function updateDefinitionRecord(e,t){Object.assign(e,createDefinitionRecord(t))}function getObservedAttributesOffset(e,t){return new Set([...e.observedAttributes].filter(e=>!t.observedAttributes.has(e)))}function patchAttributes(e,t,i){const{observedAttributes:n,attributeChangedCallback:r}=i;if(0!==n.size&&r){const a=getObservedAttributesOffset(t,i);0!==a.size&&ObjectDefineProperties(e,{setAttribute:{value:function(e,t){var i;a.has(e)?(i=nativeGetAttribute.call(this,e),nativeSetAttribute.call(this,e,t),r.call(this,e,i,valueToString(t))):nativeSetAttribute.call(this,e,t)},writable:!0,enumerable:!0,configurable:!0},removeAttribute:{value:function(e){var t;a.has(e)?(t=nativeGetAttribute.call(this,e),nativeRemoveAttribute.call(this,e),r.call(this,e,t,null)):nativeRemoveAttribute.call(this,e)},writable:!0,enumerable:!0,configurable:!0}})}}function createPivotingClass(n,r){var e=class extends NativeHTMLElement{constructor(e,t,i=!0){if(super(),e)return internalUpgrade(this,n,e,i,t),this;(e=definitionsByTag.get(r))?internalUpgrade(this,n,e,i):(pendingRegistryForElement.set(this,n),ReflectSetPrototypeOf(this,patchedHTMLElement.prototype))}connectedCallback(){var e=definitionForElement.get(this);if(e)e.connectedCallback?.call(this);else{let e=awaitingUpgrade.get(r);e||awaitingUpgrade.set(r,e=new Set),e.add(this)}}disconnectedCallback(){var e=definitionForElement.get(this);e?e.disconnectedCallback?.call(this):(e=awaitingUpgrade.get(r))&&e.delete(this)}adoptedCallback(){definitionForElement.get(this)?.adoptedCallback?.call(this)}formAssociatedCallback(){definitionForElement.get(this)?.formAssociatedCallback?.apply(this,arguments)}formDisabledCallback(){definitionForElement.get(this)?.formDisabledCallback?.apply(this,arguments)}formResetCallback(){definitionForElement.get(this)?.formResetCallback?.apply(this,arguments)}formStateRestoreCallback(){definitionForElement.get(this)?.formStateRestoreCallback?.apply(this,arguments)}attributeChangedCallback(...e){var t=definitionForElement.get(this);n!==t&&!t?.observedAttributes.has(e[0])||t.attributeChangedCallback?.apply(this,e)}};return e.observedAttributes=n.observedAttributes,e}let upgradingInstance;const definitionForElement=new WeakMap,pendingRegistryForElement=new WeakMap,pivotCtorByTag=new Map,definitionsByTag=new Map,definitionsByClass=new Map,definedPromises=new Map,definedResolvers=new Map,awaitingUpgrade=new Map;function internalUpgrade(i,e,t,n,r){ReflectSetPrototypeOf(i,t.LatestCtor.prototype),definitionForElement.set(i,t),t!==e&&patchAttributes(i,e,t),n&&(upgradingInstance=i,ReflectConstruct(t.LatestCtor,r||[]));const{observedAttributes:a,attributeChangedCallback:o}=t;0<a.size&&o&&0<(n=getObservedAttributesOffset(e,t)).size&&n.forEach(e=>{var t;nativeHasAttribute.call(i,e)&&(t=nativeGetAttribute.call(i,e),o.call(i,e,null,t))})}function getDefinitionForTagName(e,t){if(!t||!t.prototype||"object"!=typeof t.prototype)throw new TypeError("The referenced constructor is not a constructor.");let i=definitionsByTag.get(e);return i?updateDefinitionRecord(i,t):(i=createDefinitionRecord(t),definitionsByTag.set(e,i)),i}const patchedHTMLElement=function(...e){if(!new.target)throw new TypeError("Failed to construct 'HTMLElement': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");if(new.target!==patchedHTMLElement){var t=upgradingInstance;if(t)return upgradingInstance=void 0,t;t=this["constructor"],t=definitionsByClass.get(t);if(t&&t.PivotCtor)return new t.PivotCtor(t,e,!1)}throw new TypeError("Illegal constructor")};patchedHTMLElement.prototype=NativeHTMLElement.prototype,Object.assign(CustomElementRegistry.prototype,{get(...e){if(this!==cer)throw new TypeError("Illegal invocation");var t=e["0"];return ReflectApply(nativeGet,this,e)&&definitionsByTag.get(t)?.LatestCtor},define(...e){if(this!==cer)throw new TypeError("Illegal invocation");var{0:e,1:t,2:i}=e;if(i&&i.extends)throw new DOMException("NotSupportedError: ");let n=ReflectApply(nativeGet,this,[e]);if(n&&n!==definitionsByTag.get(e)?.PivotCtor)throw new DOMException(`Failed to execute 'define' on 'CustomElementRegistry': the name "${e}" has already been used with this registry`);if(definitionsByClass.get(t))throw new DOMException("Failed to execute 'define' on 'CustomElementRegistry': this constructor has already been used with this registry");const r=getDefinitionForTagName(e,t);definitionsByClass.set(t,r);var i=!!(n=pivotCtorByTag.get(e)),a=(n||(n=createPivotingClass(r,e),pivotCtorByTag.set(e,n),ReflectApply(nativeDefine,this,[e,n])),r.PivotCtor=n,awaitingUpgrade.get(e)),a=(a&&(awaitingUpgrade.delete(e),a.forEach(e=>{var t=pendingRegistryForElement.get(e);t&&(pendingRegistryForElement.delete(e),internalUpgrade(e,t,r,!0))})),definedResolvers.get(e));a&&a(t),i&&(console.warn("Redefined element",e),a=new CustomEvent("redefined-custom-element",{detail:{tagName:e,newConstructor:t}}),document.dispatchEvent(a))},whenDefined(...e){if(this!==cer)throw new TypeError("Illegal invocation");const n=e["0"];return ReflectApply(nativeWhenDefined,this,e).then(()=>{let e=definedPromises.get(n);if(!e){var i=definitionsByTag.get(n);if(i)return Promise.resolve(i.LatestCtor);let t;e=new Promise(e=>{t=e}),definedPromises.set(n,e),definedResolvers.set(n,t)}return e})},constructor:patchedHTMLElement}),window.HTMLElement=patchedHTMLElement;